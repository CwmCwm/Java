

# 个人见解
下面是术语，概念笔记，加上自己的理解和自己的场景  
也就动手写笔记，在脑里留个印象（不可能记很多的，经常用到自然而然就记住，没经常用到就留个印象，这很务实的做法，写笔记体现你的态度和方法论）  
你的工作会让你去看某些代码，业务程序员主要关注业务（当然基本功还是要的），框架程序员会关注底层代码（就学习底层代码和概念，理论实现）  



# 计算机资源
经常说的各种计算机资源。  
常见的计算机资源：CPU，内存，磁盘，IO （还有很多，详见《计算机组成原理》，如买电脑，买服务器经常用到这些概念）。     



# 进程，线程
进程是程序运行资源分配的最小单位（就是操作系统管理进程，给进程分配资源）。      
线程必须依赖进程而存在（就是你这个线程是哪个进程的啊），线程是CPU调度的最小单位（就是线程占用CPU的运行时间）。
一个进程可以有多个线程，这些线程共享同一个进程的所有资源（所以才有线程之间竞争，协作，多线程问题啊）。   

操作系统管理线程吗？ =》 操作系统只管理进程，不管线程的   
程序这个概念？ =》 就是放在磁盘中的可执行代码，其实这个概念不重要，因为不经常用到（经常说的下载“程序”）  
进程的历史大于线程，只有进程，不用线程可以吗？ =》 你去看计算机的历史，一开始只有进程，后面随着CPU的发展，才引入线程的概念，操作系统和程序才实现了线程（凡事都发展过程，当然现在直接说当前的现状，所以当前一定是都用线程的）  



# 并行和并发
并行：0如果有条高速公路 A 上面并排有 8 条车道,那么最大的并行车，辆就是 8 辆此条高速公路 A 同时并排行走的车辆小于等于 8 辆的时候,车辆就可以并行运行。
CPU 也是这个原理,一个 CPU 相当于一个高速公路 A,核心数或者线程数就相当于并排可以通行的车道;而多个 CPU 就相当于并排有多条高速公路,而每个高速公路并排有多个车道。
并发：一定要加个单位时间,也就是说单位时间内并发量是多少? 离开了单位时间其实是没有意义的。

并行是一种能力，并发是一种目的。如老板要1s处理100次http请求（这是目的），那你说加CPU啊（这是能力），能力能达成目的。  
其实并发用到的频率大于并行



# CPU的核心和线程数
多核数：单芯片多处理器（其实就是集成电路的发展，一个芯片能集成多个处理器，从而提高整个芯片的计算能力）。既然一个芯片有多个处理器，每个处理器是独立的啊（所以这是硬件级别的并行，也就是真正的并行数量）
多线程：同一个处理器上多个线程同步执行（这里多线程对应处理器这个概念）
核心数和线程数：增加核心数也就增加并发的线程数



# CPU时间片轮询机制
你只要认知CPU的计算处理速度是人类感知处理速度的很多很多倍（如人类视觉感知是1/24s，一个CPU计算指令是3ns，关于CPU更细节的东西自己百度去），就能理解CPU时间片轮询机制。   
因为CPU执行速度太快了，所以1s能分成很多时间片给不同线程（进程）去占用执行，所以你的电脑就能同时听音乐，qq聊天，看浏览器等等。  
   


# 高并发编程的好处和注意事项
优点：
1.充分利用CPU资源（因为CPU的多核，计算处理速度太快了）
2.加快用户响应时间（能充分利用CPU资源就能加快用户响应时间）
3.可以使你的代码模块化，异步化，简单化（现电商系统，下订单和给用户发送短信、邮件就可以进行拆分，将给用户发送短信、邮件这两个步骤独立为单独的模块，并交给其他线程去执行。）

注意事项
1.线程间的安全（因为多个线程共享同一个进程资源）
2.线程之间的死锁（还是因为多个线程共享同一个进程资源）
3.线程太多了会将服务器资源耗尽形成死机当机（启用线程会消耗内存资源，越多线程就消耗越多内存。线程间的切换是需要时间的，太多线程就会把时间浪费在线程切换上。还有有些资源是有限的，如文件描述符）



# Java中的线程
java程序天生就是多线程的（基本现代编程语言都是多线程的啊，因为语言设计当时，CPU是多核的）  
java中线程的状态流转图 [](./resources/java中线程状态流转图.png)  
```
// 详见java.lang.Thread 中的方法，结合上图（记忆一下咯）  
// 理解学习吧，实际编程都是用线程池。

// yield方法 使当前线程让出 CPU 占有权，进入可运行状态，但让出的时间是不可设定的，不会释放锁资源。 
// 所有执行 yield()的线程有可能在进入到就绪状态后会被操作系统再次选中 马上又被执行。
// 其实写代码时基本没用到，我是没想到实际场景
public static native void yield();

// sleep方法 使当前线程进入阻塞状态，不会释放资源。阻塞一段时间后就回到可运行状态
// 写demo，学习时经常用到。实际很少用到
public static native void sleep(long millis) throws InterruptedException;

// start方法 是创建的线程（就是new出来的线程后，进入可运行状态）
// 写demo，学习时经常用到。实际上用线程池
public synchronized void start()

// run方法 线程进入运行状态，那运行啥，就是run方法啊
public void run() 

// interrupt方法 其他线程调用这个线程的interrupt方法，就将这个线程的   // Just to set the interrupt flag   就是设置中断标识
// 上面说了就设置中断标识，至于run方法代码中是否有检查中断标识，是否处理做对应处理，当然代码都你写的，你就会写咯
public void interrupt()

// join方法 举例：A线程.join(B线程)，那么就能保证B线程先执行，A线程必然在B线程执行完后再执行
// 实际上你的代码后先后顺序的话，一般就写在同一个run方法中，干嘛拆成在两个线程中，还要用join来保证顺序呢？
public final void join() throws InterruptedException 


// 还有其他方法，但不推荐，或过期，那就不用理啊，干嘛去看那些方法

```  
线程优先级，没啥用（因为线程的调度还是看操作系统，你要知道谁管理计算机资源，当然是操作系统啦，百度计算的层次结构，java线程其实就是与操作系统线程进行映射）。    
所以线程优先级只是一种性质上是有这个优先级，但实际上不可控啊，当然有得设置就设置呗。优先级越高的线程越容易被系统选择执行   




# 线程调度
线程调度是指系统为线程分配 CPU 使用权的过程，主要调度方式有两种：
协同式线程调度(Cooperative Threads-Scheduling)
抢占式线程调度(Preemptive Threads-Scheduling)

所以在面试中如果遇到相关的问题，可以这样回答：Java 中的线程是通过映射到操作系统的原生线程上实现的，所以线程的调度最终取决于操作系统，
而操作系统级别，OS 是以抢占式调度线程，我们可以认为线程是抢占式的。Java 虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用 CPU，如
果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。而且操作系统中线程的
优先级有时并不能和 Java 中的一一对应，所以 Java 优先级并不是特别靠谱。但是在 Java 中，因为 Java 没有提供安全的抢占式方法来停止线程，要安全的停止线程只能以协作式的方式。

所以以上学习学习，因为实际上你用到这些理论。



# 守护线程
Daemon（守护）线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。
这意味着，当一个 Java 虚拟机中不存在非 Daemon 线程的时候，Java 虚拟机将会退出。
可以通过调用 Thread.setDaemon(true)将线程设置为Daemon线程。
我们一般用不上，比如垃圾回收线程就是 Daemon 线程。（所以就是个辅助嘛，辅助buff，可有可无，有当然最好啦）

Daemon 线程被用作完成支持性工作，但是在 Java 虚拟机退出时 Daemon 线程中的 finally 块并不一定会执行。
在构建 Daemon 线程时，不能依靠 finally 块中的内容来确保执行关闭或清理资源的逻辑。（是这样说，但是我们经常使用的线程都是非Daemon线程啊，所以finally块一定会执行啊）



# 线程间的共享和协作
线程间的共享，同一个进程中的线程共享这个进程的资源，线程用到一些共享资源，那就要规则啦（这是显而易见，代入生活能找到示例啊）  
当然线程有自己的线程栈空间（这个线程栈空间就是各个线程互相独立哦，不共享的，JVM的默认栈大小是1M）   

因为有些资源是共享的，所以线程间要协作，不然会出问题的（如脏数据）  
线程间的协作从概念上说就一种，锁机制/串行 （乐观锁cas理解成锁粒度很细，cas是CPU保证的）   
下面就是java中各种锁   

## java中的锁
### synchronized 内置锁  
关键字synchronized 可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。   
对象锁和类锁： 对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的 class 对象上的。
我们知道，类的对象实例可以有很多个，但是每个类只有一个 class 对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。
但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，类锁其实锁的是每个类的对应的 class 对象。类锁和对象锁之间也是互不干扰的。（所以其实就只有对象锁，类锁只是个概念名称，本质就是对象锁）  
错误的加锁和原因分析，见pdf，对 Integer对象 加锁， Integer + 1 会返回新的 Integer对象，变量引用都变啦，这没想到   

### volatile，最轻量的同步机制
volatile 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。    
但是 volatile 不能保证数据在多个线程下同时写时的线程安全， 所以volatile 最适用的场景：一个线程写，多个线程读。   

### ThreadLocal
ThreadLocal与 synchronized 有本质的差别。synchronized 是利用锁的机制，使变量或代码块在某一时该仅仅能被一个线程訪问。
而 ThreadLocal 为每个线程都提供了变量的副本，使得每个线程在某一时间訪问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。
（所以 ThreadLocal 就是线程间不共享，每个线程拥有自己独占的资源，切记这个点。对写代码，实例化对象有简化帮助。实际场景见spring DAO层，spring MVC）

ThreadLocal 原理见代码， ThreadLocal 的内部类 ThreadLocalMap， 不是很难，但有点绕，有效通用去理解的方法就是写demo进行debug。 （涉及WeakReference 弱引用的概念）  
ThreadLocalMap.Entry 为什么是 extends WeakReference<ThreadLocal<?>> 弱引用？ =》 关键点为是否回收 ThreadLocal变量的引用对象，这个见示例 com.demo.thread.ThreadLocalOOMMain  
ThreadLocal 可能导致内存泄漏 =》 同样见示例 com.demo.thread.ThreadLocalOOMMain

引用的语义
```
// 在内存中创建了Object对象 （就是JVM中的堆空间）
Object o = new Object();

// 随后将 o 置为null，表示变量o 不再指向上面创建的 Object 的对象实例，不代表这 个对象实例不存在了（要被JVM的垃圾回收器回收后才会不存在）
o = null;

// 只就是引用的语义和实际流程
```

强引用 就是指在程序代码之中普遍存在的，类似 "Object obj=new Object（）" 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象实例。     
软引用 是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象实例列进回收范围之中进行第二次回收。
如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK1.2 之后，提供了 SoftReference 类来实现软引用。    
弱引用 也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象实例只能生存到下一次垃圾收集发生之前。
当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象实例。在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。    
虚引用 也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象实例是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。
为一个对象设置虚引用关联的唯一目的就是能在这个对象实例被收集器回收时收到一个系统通知。在 JDK 1.2 之后，提供了PhantomReference 类来实现虚引用。    

上面各种引用的区别就是GC回收时如何处理这些引用对应的实例对象。   

总结
JVM 利用设置 ThreadLocalMap 的 Key 为弱引用，来避免内存泄露。
JVM 利用调用 remove、get、set 方法的时候，回收弱引用。
当 ThreadLocal 存储很多 Key 为 null 的 Entry 的时候，而不再去调用 remove、get、set 方法，那么将导致内存泄漏。
使用线程池+ ThreadLocal 时要小心，因为这种情况下，线程是一直在不断的重复运行的，从而也就造成了 value 可能造成累积的情况。 （就是说执行任务时要清理重新指定资源，因为当前线程执行上个任务后，可能保留之前的数据）



### 线程间的协作
线程之间相互配合，完成某项工作（要互相配合哦，实际上写代码线程能自己独立完成就独立完成，干嘛要配合。配合一般是业务上配合，会有中间存储的如关系数据库，redis。）    
等待/通知机制  wait/notify    
对共享的对象实例使用wait/notify    
注意 wait/notify 是java.lang.Object 的方法  
wait/notify   代码模板照着写就行了    



面试题
1. 调用 yield() 、sleep()、wait()、notify()等方法对锁有何影响？ =》 画线程状态流转图就知道了
2. yield() 、sleep()被调用后，都不会释放当前线程所持有的锁。 =》 是啊， yield() 、sleep()方法只是让当前线程不占用CPU，没有释放锁。  
3. 调用 wait()方法后，会释放当前线程持有的对象的锁，而且当前被唤醒后，会重新去竞争对象的锁，锁竞争到后才会执行 wait 方法后面的代码。   
4. 调用 notify()系列方法后，对锁无影响，线程只有在 syn 同步代码执行完后才会自然而然的释放锁，所以 notify()系列方法一般都是 syn 同步代码的最后一行。 =》 是啊，所以照着模板写代码就行了



# 线程的并发工具类
分而治之的思想： 将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。（难度就是这个大问题可以拆分成多个相同的小问题吗？如何拆分？）    
分治策略是：对于一个规模为 n 的问题，若该问题可以容易地解决（比如说规模 n 较小）则直接解决，
否则将其分解为 k 个规模较小的子问题，这些子问题互相独立且与原问题形式相同(子问题相互之间有联系就会变为动态规范算法)，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。    
（分治策略就是告诉你如何拆分的策略，这只是个策略，具体现实问题需要实际解决方案）   

归并排序，见[笔记_Java并发编程.pdf](./resources/笔记_Java并发编程.pdf)，里面有图例，很好理解       
当然理解完算法后，代码实现算法都是苦逼的，各种判断，各种边界   





# Fork-Join 原理   
Fork-Join框架就是将一个大任务，进行拆分Fork成若干小任务（拆到不能再拆时），小任务解决完后，将一个个小任务的运算结果进行Join汇总。    
思想就是分而治之，实操就是要写如何拆分任务的代码，小任务的计算代码，将小任务结果进行汇总的代码。   
示例代码 ForkJoin1.java    ForkJoin2.java

## 工作密取  
即当前线程的Task池已经执行完毕后，该线程自动取得其他线程的Task池取出Task继续执行。（就是你活干好了，顺便帮别干活）    
工作密取是Fork-Join框架已经实现的，该框架就是帮你解决线程调度问题的，具体业务你当然要写代码，你不用Fork-Join框架也可以多线程计算（其实分布式计算的理论是相同）





# CountDownLatch
CountDownLatch 这个类能够使一个线程等待其他线程完成各自的工作后再执行。  
CountDownLatch 是通过一个计数器来实现的，计数器的初始值为初始任务的数量。每当完成了一个任务后，计数器的值就会减 1。当计数器值到达 0 时，
它表示所有的已经完成了任务，然后在闭锁上等待 CountDownLatch.await()方法的线程就可以恢复执行任务。
示例代码 CountDownLatchMain

# CyclicBarrier
CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，
直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。   
其实  CyclicBarrier（重复利用） 和 CountDownLatch（一次性） ，就是最大的区别了   
示例代码  CyclicBarrierMain

# Semaphore
Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。
应用场景 Semaphore 可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。  













